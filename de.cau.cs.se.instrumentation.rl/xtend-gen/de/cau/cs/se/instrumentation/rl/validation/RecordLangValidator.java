/**
 * generated by Xtext
 */
package de.cau.cs.se.instrumentation.rl.validation;

import com.google.common.base.Objects;
import de.cau.cs.se.instrumentation.rl.generator.InternalErrorException;
import de.cau.cs.se.instrumentation.rl.recordLang.ArrayLiteral;
import de.cau.cs.se.instrumentation.rl.recordLang.ArraySize;
import de.cau.cs.se.instrumentation.rl.recordLang.BooleanLiteral;
import de.cau.cs.se.instrumentation.rl.recordLang.BuiltInValueLiteral;
import de.cau.cs.se.instrumentation.rl.recordLang.Classifier;
import de.cau.cs.se.instrumentation.rl.recordLang.Constant;
import de.cau.cs.se.instrumentation.rl.recordLang.ConstantLiteral;
import de.cau.cs.se.instrumentation.rl.recordLang.FloatLiteral;
import de.cau.cs.se.instrumentation.rl.recordLang.IntLiteral;
import de.cau.cs.se.instrumentation.rl.recordLang.Literal;
import de.cau.cs.se.instrumentation.rl.recordLang.Property;
import de.cau.cs.se.instrumentation.rl.recordLang.RecordLangFactory;
import de.cau.cs.se.instrumentation.rl.recordLang.RecordLangPackage;
import de.cau.cs.se.instrumentation.rl.recordLang.RecordType;
import de.cau.cs.se.instrumentation.rl.recordLang.StringLiteral;
import de.cau.cs.se.instrumentation.rl.recordLang.TemplateType;
import de.cau.cs.se.instrumentation.rl.recordLang.Type;
import de.cau.cs.se.instrumentation.rl.typing.PrimitiveTypes;
import de.cau.cs.se.instrumentation.rl.validation.AbstractRecordLangValidator;
import de.cau.cs.se.instrumentation.rl.validation.PropertyEvaluation;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EDataType;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import org.eclipse.xtext.xbase.lib.Pair;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;

/**
 * Custom validation rules.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
@SuppressWarnings("all")
public class RecordLangValidator extends AbstractRecordLangValidator {
  public final static String INVALID_NAME = "invalidName";
  
  /**
   * Check if an alias is a cyclic definition.
   */
  @Check
  public void checkCyclicAlias(final Property property) {
    Property _referTo = property.getReferTo();
    boolean _notEquals = (!Objects.equal(_referTo, null));
    if (_notEquals) {
      final List<Property> visitedProperties = new ArrayList<Property>();
      visitedProperties.add(property);
      Property referredProperty = property.getReferTo();
      while ((!Objects.equal(referredProperty.getReferTo(), null))) {
        {
          boolean _contains = visitedProperties.contains(referredProperty);
          if (_contains) {
            String _name = property.getName();
            String _plus = ("Property alias " + _name);
            String _plus_1 = (_plus + " has a cyclic definition.");
            this.error(_plus_1, 
              RecordLangPackage.Literals.PROPERTY__REFER_TO, 
              RecordLangValidator.INVALID_NAME);
            return;
          }
          visitedProperties.add(referredProperty);
          Property _referTo_1 = referredProperty.getReferTo();
          referredProperty = _referTo_1;
        }
      }
    }
  }
  
  /**
   * Check whether a property has been declared twice with different types.
   */
  @Check
  public void checkPropertyDeclaration(final Property property) {
    EObject _eContainer = property.eContainer();
    if ((_eContainer instanceof Type)) {
      EObject _eContainer_1 = property.eContainer();
      List<Property> _collectAllProperties = PropertyEvaluation.collectAllProperties(((Type) _eContainer_1));
      final Function1<Property, Boolean> _function = new Function1<Property, Boolean>() {
        public Boolean apply(final Property p) {
          boolean _and = false;
          String _name = p.getName();
          String _name_1 = property.getName();
          boolean _equals = _name.equals(_name_1);
          if (!_equals) {
            _and = false;
          } else {
            boolean _notEquals = (!Objects.equal(p, property));
            _and = _notEquals;
          }
          return Boolean.valueOf(_and);
        }
      };
      boolean _exists = IterableExtensions.<Property>exists(_collectAllProperties, _function);
      if (_exists) {
        EObject _eContainer_2 = property.eContainer();
        List<Property> _collectAllProperties_1 = PropertyEvaluation.collectAllProperties(((Type) _eContainer_2));
        final Function1<Property, Boolean> _function_1 = new Function1<Property, Boolean>() {
          public Boolean apply(final Property p) {
            boolean _and = false;
            String _name = p.getName();
            String _name_1 = property.getName();
            boolean _equals = _name.equals(_name_1);
            if (!_equals) {
              _and = false;
            } else {
              boolean _notEquals = (!Objects.equal(p, property));
              _and = _notEquals;
            }
            return Boolean.valueOf(_and);
          }
        };
        final Property otherProperty = IterableExtensions.<Property>findFirst(_collectAllProperties_1, _function_1);
        EObject _eContainer_3 = otherProperty.eContainer();
        String _name = ((Type) _eContainer_3).getName();
        String _plus = ("Property has been defined in " + _name);
        String _plus_1 = (_plus + ". Cannot be declared again.");
        this.error(_plus_1, 
          RecordLangPackage.Literals.PROPERTY__NAME, 
          RecordLangValidator.INVALID_NAME);
      }
    }
  }
  
  /**
   * Check a RecordType for multiple inheritance of the same property with different types.
   */
  @Check
  public void checkRecordTypeComposition(final RecordType type) {
    final Collection<Property> properties = PropertyEvaluation.collectAllProperties(type);
    final Function1<Property, Boolean> _function = new Function1<Property, Boolean>() {
      public Boolean apply(final Property p) {
        final Function1<Property, Boolean> _function = new Function1<Property, Boolean>() {
          public Boolean apply(final Property pInner) {
            boolean _and = false;
            String _name = p.getName();
            String _name_1 = pInner.getName();
            boolean _equals = _name.equals(_name_1);
            if (!_equals) {
              _and = false;
            } else {
              boolean _notEquals = (!Objects.equal(p, pInner));
              _and = _notEquals;
            }
            return Boolean.valueOf(_and);
          }
        };
        return Boolean.valueOf(IterableExtensions.<Property>exists(properties, _function));
      }
    };
    boolean _exists = IterableExtensions.<Property>exists(properties, _function);
    if (_exists) {
      final Collection<Pair<Property, Property>> duplicates = new ArrayList<Pair<Property, Property>>();
      final Procedure1<Property> _function_1 = new Procedure1<Property>() {
        public void apply(final Property p) {
          Pair<Property, Property> _findDuplicate = RecordLangValidator.this.findDuplicate(p, properties);
          duplicates.add(_findDuplicate);
        }
      };
      IterableExtensions.<Property>forEach(properties, _function_1);
      final Procedure1<Pair<Property, Property>> _function_2 = new Procedure1<Pair<Property, Property>>() {
        public void apply(final Pair<Property, Property> entry) {
          Property _key = entry.getKey();
          String _name = _key.getName();
          String _plus = ("Multiple property inheritance form " + _name);
          String _plus_1 = (_plus + 
            " inherited from ");
          Property _key_1 = entry.getKey();
          EObject _eContainer = _key_1.eContainer();
          String _name_1 = ((Type) _eContainer).getName();
          String _plus_2 = (_plus_1 + _name_1);
          String _plus_3 = (_plus_2 + " and ");
          Property _value = entry.getValue();
          EObject _eContainer_1 = _value.eContainer();
          String _name_2 = ((Type) _eContainer_1).getName();
          String _plus_4 = (_plus_3 + _name_2);
          RecordLangValidator.this.error(_plus_4, 
            RecordLangPackage.Literals.TYPE__PARENTS, 
            RecordLangValidator.INVALID_NAME);
        }
      };
      IterableExtensions.<Pair<Property, Property>>forEach(duplicates, _function_2);
    }
  }
  
  /**
   * Check a PartialType for multiple inheritance of the same property with different types.
   */
  @Check
  public void checkPartialTypeComposition(final TemplateType type) {
    final Collection<Property> properties = PropertyEvaluation.collectAllProperties(type);
    final Function1<Property, Boolean> _function = new Function1<Property, Boolean>() {
      public Boolean apply(final Property p) {
        final Function1<Property, Boolean> _function = new Function1<Property, Boolean>() {
          public Boolean apply(final Property pInner) {
            boolean _and = false;
            String _name = p.getName();
            String _name_1 = pInner.getName();
            boolean _equals = _name.equals(_name_1);
            if (!_equals) {
              _and = false;
            } else {
              boolean _notEquals = (!Objects.equal(p, pInner));
              _and = _notEquals;
            }
            return Boolean.valueOf(_and);
          }
        };
        return Boolean.valueOf(IterableExtensions.<Property>exists(properties, _function));
      }
    };
    boolean _exists = IterableExtensions.<Property>exists(properties, _function);
    if (_exists) {
      final Collection<Pair<Property, Property>> duplicates = new ArrayList<Pair<Property, Property>>();
      final Procedure1<Property> _function_1 = new Procedure1<Property>() {
        public void apply(final Property p) {
          Pair<Property, Property> _findDuplicate = RecordLangValidator.this.findDuplicate(p, properties);
          duplicates.add(_findDuplicate);
        }
      };
      IterableExtensions.<Property>forEach(properties, _function_1);
      final Procedure1<Pair<Property, Property>> _function_2 = new Procedure1<Pair<Property, Property>>() {
        public void apply(final Pair<Property, Property> entry) {
          Property _key = entry.getKey();
          String _name = _key.getName();
          String _plus = ("Multiple property inheritance from " + _name);
          String _plus_1 = (_plus + 
            " inherited from ");
          Property _key_1 = entry.getKey();
          EObject _eContainer = _key_1.eContainer();
          String _name_1 = ((Type) _eContainer).getName();
          String _plus_2 = (_plus_1 + _name_1);
          String _plus_3 = (_plus_2 + " and ");
          Property _value = entry.getValue();
          EObject _eContainer_1 = _value.eContainer();
          String _name_2 = ((Type) _eContainer_1).getName();
          String _plus_4 = (_plus_3 + _name_2);
          RecordLangValidator.this.error(_plus_4, 
            RecordLangPackage.Literals.TYPE__PARENTS, 
            RecordLangValidator.INVALID_NAME);
        }
      };
      IterableExtensions.<Pair<Property, Property>>forEach(duplicates, _function_2);
    }
  }
  
  /**
   * Check it a given constant's type and the assigned value's type match.
   */
  @Check
  public void checkConstantValueTyping(final Constant constant) {
    Literal _value = constant.getValue();
    boolean _notEquals = (!Objects.equal(_value, null));
    if (_notEquals) {
      Classifier _type = constant.getType();
      Literal _value_1 = constant.getValue();
      Classifier _type_1 = this.getType(_value_1);
      Literal _value_2 = constant.getValue();
      boolean _compareTypesInAssignment = this.compareTypesInAssignment(_type, _type_1, _value_2);
      boolean _not = (!_compareTypesInAssignment);
      if (_not) {
        Classifier _type_2 = constant.getType();
        String _createFQNTypeName = this.createFQNTypeName(_type_2);
        String _plus = ("Constant type \'" + _createFQNTypeName);
        String _plus_1 = (_plus + "\' does not match value type \'");
        Literal _value_3 = constant.getValue();
        Classifier _type_3 = this.getType(_value_3);
        String _createFQNTypeName_1 = this.createFQNTypeName(_type_3);
        String _plus_2 = (_plus_1 + _createFQNTypeName_1);
        String _plus_3 = (_plus_2 + "\'.");
        this.error(_plus_3, 
          RecordLangPackage.Literals.CONSTANT__TYPE, 
          RecordLangValidator.INVALID_NAME);
      }
    }
  }
  
  /**
   * Check it a given property's type and the assigned value's type match.
   */
  @Check
  public void checkPropertyValueTyping(final Property property) {
    Literal _value = property.getValue();
    boolean _notEquals = (!Objects.equal(_value, null));
    if (_notEquals) {
      Classifier _type = property.getType();
      Literal _value_1 = property.getValue();
      Classifier _type_1 = this.getType(_value_1);
      Literal _value_2 = property.getValue();
      boolean _compareTypesInAssignment = this.compareTypesInAssignment(_type, _type_1, _value_2);
      boolean _not = (!_compareTypesInAssignment);
      if (_not) {
        Classifier _type_2 = property.getType();
        String _createFQNTypeName = this.createFQNTypeName(_type_2);
        String _plus = ("Property type \'" + _createFQNTypeName);
        String _plus_1 = (_plus + "\' does not match value type \'");
        Literal _value_3 = property.getValue();
        Classifier _type_3 = this.getType(_value_3);
        String _createFQNTypeName_1 = this.createFQNTypeName(_type_3);
        String _plus_2 = (_plus_1 + _createFQNTypeName_1);
        String _plus_3 = (_plus_2 + "\'.");
        this.error(_plus_3, 
          RecordLangPackage.Literals.PROPERTY__TYPE, 
          RecordLangValidator.INVALID_NAME);
      }
    }
  }
  
  /**
   * Check it a given type of one array element matches the other.
   */
  @Check
  public void checkValueTyping(final ArrayLiteral literal) {
    EList<Literal> _literals = literal.getLiterals();
    int _size = _literals.size();
    boolean _greaterThan = (_size > 0);
    if (_greaterThan) {
      EList<Literal> _literals_1 = literal.getLiterals();
      Literal _get = _literals_1.get(0);
      final Classifier type = this.getType(_get);
      EList<Literal> _literals_2 = literal.getLiterals();
      final Function1<Literal, Boolean> _function = new Function1<Literal, Boolean>() {
        public Boolean apply(final Literal element) {
          Classifier _type = RecordLangValidator.this.getType(element);
          return Boolean.valueOf(RecordLangValidator.this.typeEquality(_type, type));
        }
      };
      boolean _forall = IterableExtensions.<Literal>forall(_literals_2, _function);
      boolean _not = (!_forall);
      if (_not) {
        EList<Literal> _literals_3 = literal.getLiterals();
        final Function1<Literal, String> _function_1 = new Function1<Literal, String>() {
          public String apply(final Literal it) {
            Classifier _type = RecordLangValidator.this.getType(it);
            return RecordLangValidator.this.createFQNTypeName(_type);
          }
        };
        List<String> _map = ListExtensions.<Literal, String>map(_literals_3, _function_1);
        String _join = IterableExtensions.join(_map, ", ");
        String _plus = ("Value types " + _join);
        String _plus_1 = (_plus + " do not match");
        this.error(_plus_1, 
          RecordLangPackage.Literals.ARRAY_LITERAL__LITERALS);
      }
    }
  }
  
  /**
   * Create a full qualified type name based on a classifier.
   * 
   * @param classifier the classifier where the FQN is computed for
   */
  public String createFQNTypeName(final Classifier classifier) {
    EClassifier _class_ = classifier.getClass_();
    String _name = _class_.getName();
    EList<ArraySize> _sizes = classifier.getSizes();
    final Function1<ArraySize, String> _function = new Function1<ArraySize, String>() {
      public String apply(final ArraySize it) {
        Object _xifexpression = null;
        int _size = it.getSize();
        boolean _notEquals = (_size != 0);
        if (_notEquals) {
          _xifexpression = Integer.valueOf(it.getSize());
        } else {
          _xifexpression = "";
        }
        String _plus = ("[" + ((Comparable<?>)_xifexpression));
        return (_plus + "]");
      }
    };
    List<String> _map = ListExtensions.<ArraySize, String>map(_sizes, _function);
    String _join = IterableExtensions.join(_map);
    return (_name + _join);
  }
  
  /**
   * Check if types are a exact match.
   */
  public boolean typeEquality(final Classifier left, final Classifier right) {
    EClassifier _class_ = left.getClass_();
    String _name = _class_.getName();
    EClassifier _class__1 = right.getClass_();
    String _name_1 = _class__1.getName();
    boolean _equals = _name.equals(_name_1);
    if (_equals) {
      EList<ArraySize> _sizes = left.getSizes();
      int _size = _sizes.size();
      EList<ArraySize> _sizes_1 = right.getSizes();
      int _size_1 = _sizes_1.size();
      boolean _equals_1 = (_size == _size_1);
      if (_equals_1) {
        int i = 0;
        while ((i < left.getSizes().size())) {
          {
            EList<ArraySize> _sizes_2 = left.getSizes();
            ArraySize _get = _sizes_2.get(i);
            int _size_2 = _get.getSize();
            EList<ArraySize> _sizes_3 = right.getSizes();
            ArraySize _get_1 = _sizes_3.get(i);
            int _size_3 = _get_1.getSize();
            boolean _notEquals = (_size_2 != _size_3);
            if (_notEquals) {
              return false;
            }
            i = (i + 1);
          }
        }
        return true;
      }
    }
    return false;
  }
  
  /**
   * Compare two types for a type match in a value assignment.
   */
  public boolean compareTypesInAssignment(final Classifier left, final Classifier right, final Literal literal) {
    boolean _and = false;
    de.cau.cs.se.instrumentation.rl.recordLang.Package _package = left.getPackage();
    boolean _notEquals = (!Objects.equal(_package, null));
    if (!_notEquals) {
      _and = false;
    } else {
      de.cau.cs.se.instrumentation.rl.recordLang.Package _package_1 = right.getPackage();
      boolean _notEquals_1 = (!Objects.equal(_package_1, null));
      _and = _notEquals_1;
    }
    if (_and) {
      de.cau.cs.se.instrumentation.rl.recordLang.Package _package_2 = left.getPackage();
      EPackage _package_3 = _package_2.getPackage();
      String _nsURI = _package_3.getNsURI();
      de.cau.cs.se.instrumentation.rl.recordLang.Package _package_4 = right.getPackage();
      EPackage _package_5 = _package_4.getPackage();
      String _nsURI_1 = _package_5.getNsURI();
      boolean _equals = _nsURI.equals(_nsURI_1);
      if (_equals) {
        return this.compareClassifierTypesInAssignment(left, right, literal);
      } else {
        return false;
      }
    } else {
      boolean _and_1 = false;
      de.cau.cs.se.instrumentation.rl.recordLang.Package _package_6 = left.getPackage();
      boolean _equals_1 = Objects.equal(_package_6, null);
      if (!_equals_1) {
        _and_1 = false;
      } else {
        de.cau.cs.se.instrumentation.rl.recordLang.Package _package_7 = right.getPackage();
        boolean _equals_2 = Objects.equal(_package_7, null);
        _and_1 = _equals_2;
      }
      if (_and_1) {
        return this.compareClassifierTypesInAssignment(left, right, literal);
      } else {
        return false;
      }
    }
  }
  
  /**
   * Check if types match in an assignment.
   */
  public boolean compareClassifierTypesInAssignment(final Classifier left, final Classifier right, final Literal literal) {
    boolean _compareClassifierTypeEquvalenceSet = this.compareClassifierTypeEquvalenceSet(left, right, literal);
    if (_compareClassifierTypeEquvalenceSet) {
      EList<ArraySize> _sizes = left.getSizes();
      int _size = _sizes.size();
      EList<ArraySize> _sizes_1 = right.getSizes();
      int _size_1 = _sizes_1.size();
      boolean _equals = (_size == _size_1);
      if (_equals) {
        int i = 0;
        while ((i < left.getSizes().size())) {
          {
            boolean _and = false;
            EList<ArraySize> _sizes_2 = left.getSizes();
            ArraySize _get = _sizes_2.get(i);
            int _size_2 = _get.getSize();
            EList<ArraySize> _sizes_3 = right.getSizes();
            ArraySize _get_1 = _sizes_3.get(i);
            int _size_3 = _get_1.getSize();
            boolean _notEquals = (_size_2 != _size_3);
            if (!_notEquals) {
              _and = false;
            } else {
              EList<ArraySize> _sizes_4 = left.getSizes();
              ArraySize _get_2 = _sizes_4.get(i);
              int _size_4 = _get_2.getSize();
              boolean _notEquals_1 = (_size_4 != 0);
              _and = _notEquals_1;
            }
            if (_and) {
              return false;
            }
            i = (i + 1);
          }
        }
        return true;
      } else {
        return false;
      }
    } else {
      return false;
    }
  }
  
  /**
   * Check if the left and the right type are compatible. First check if they are identical. If
   * not use checkTypeEquivalenceSet to check for compatible types. This is required for constants values.
   */
  public boolean compareClassifierTypeEquvalenceSet(final Classifier left, final Classifier right, final Literal literal) {
    boolean _xifexpression = false;
    EClassifier _class_ = left.getClass_();
    String _name = _class_.getName();
    EClassifier _class__1 = right.getClass_();
    String _name_1 = _class__1.getName();
    boolean _equals = _name.equals(_name_1);
    if (_equals) {
      _xifexpression = true;
    } else {
      _xifexpression = this.checkTypeEquivalenceSet(left, right, literal);
    }
    return _xifexpression;
  }
  
  /**
   * Check if types match.
   */
  public boolean checkTypeEquivalenceSet(final Classifier left, final Classifier right, final Literal literal) {
    boolean _xifexpression = false;
    EClassifier _class_ = left.getClass_();
    String _name = _class_.getName();
    boolean _equals = _name.equals("double");
    if (_equals) {
      boolean _xifexpression_1 = false;
      EClassifier _class__1 = right.getClass_();
      String _name_1 = _class__1.getName();
      boolean _equals_1 = _name_1.equals("float");
      if (_equals_1) {
        boolean _xifexpression_2 = false;
        if ((literal instanceof FloatLiteral)) {
          _xifexpression_2 = true;
        } else {
          boolean _xifexpression_3 = false;
          if ((literal instanceof ArrayLiteral)) {
            _xifexpression_3 = this.checkAllLiteralsArtOfType(FloatLiteral.class, ((ArrayLiteral) literal));
          }
          _xifexpression_2 = _xifexpression_3;
        }
        _xifexpression_1 = _xifexpression_2;
      } else {
        _xifexpression_1 = false;
      }
      _xifexpression = _xifexpression_1;
    } else {
      boolean _xifexpression_4 = false;
      EClassifier _class__2 = left.getClass_();
      String _name_2 = _class__2.getName();
      boolean _equals_2 = _name_2.equals("long");
      if (_equals_2) {
        boolean _xifexpression_5 = false;
        EClassifier _class__3 = right.getClass_();
        String _name_3 = _class__3.getName();
        boolean _equals_3 = _name_3.equals("int");
        if (_equals_3) {
          boolean _xifexpression_6 = false;
          if ((literal instanceof IntLiteral)) {
            boolean _xifexpression_7 = false;
            boolean _and = false;
            int _value = ((IntLiteral) literal).getValue();
            boolean _greaterEqualsThan = (_value >= Long.MIN_VALUE);
            if (!_greaterEqualsThan) {
              _and = false;
            } else {
              int _value_1 = ((IntLiteral) literal).getValue();
              boolean _lessEqualsThan = (_value_1 <= Long.MAX_VALUE);
              _and = _lessEqualsThan;
            }
            if (_and) {
              _xifexpression_7 = true;
            } else {
              _xifexpression_7 = false;
            }
            _xifexpression_6 = _xifexpression_7;
          } else {
            boolean _xifexpression_8 = false;
            if ((literal instanceof ArrayLiteral)) {
              _xifexpression_8 = this.checkAllLiteralsArtOfType(IntLiteral.class, ((ArrayLiteral) literal));
            }
            _xifexpression_6 = _xifexpression_8;
          }
          _xifexpression_5 = _xifexpression_6;
        } else {
          _xifexpression_5 = false;
        }
        _xifexpression_4 = _xifexpression_5;
      } else {
        boolean _xifexpression_9 = false;
        EClassifier _class__4 = left.getClass_();
        String _name_4 = _class__4.getName();
        boolean _equals_4 = _name_4.equals("byte");
        if (_equals_4) {
          boolean _xifexpression_10 = false;
          EClassifier _class__5 = right.getClass_();
          String _name_5 = _class__5.getName();
          boolean _equals_5 = _name_5.equals("int");
          if (_equals_5) {
            boolean _xifexpression_11 = false;
            if ((literal instanceof IntLiteral)) {
              boolean _xifexpression_12 = false;
              boolean _and_1 = false;
              int _value_2 = ((IntLiteral) literal).getValue();
              boolean _greaterEqualsThan_1 = (_value_2 >= Byte.MIN_VALUE);
              if (!_greaterEqualsThan_1) {
                _and_1 = false;
              } else {
                int _value_3 = ((IntLiteral) literal).getValue();
                boolean _lessEqualsThan_1 = (_value_3 <= Byte.MAX_VALUE);
                _and_1 = _lessEqualsThan_1;
              }
              if (_and_1) {
                _xifexpression_12 = true;
              } else {
                _xifexpression_12 = false;
              }
              _xifexpression_11 = _xifexpression_12;
            } else {
              boolean _xifexpression_13 = false;
              if ((literal instanceof ArrayLiteral)) {
                _xifexpression_13 = this.checkAllLiteralsArtOfType(IntLiteral.class, ((ArrayLiteral) literal));
              }
              _xifexpression_11 = _xifexpression_13;
            }
            _xifexpression_10 = _xifexpression_11;
          } else {
            _xifexpression_10 = false;
          }
          _xifexpression_9 = _xifexpression_10;
        } else {
          boolean _xifexpression_14 = false;
          EClassifier _class__6 = left.getClass_();
          String _name_6 = _class__6.getName();
          boolean _equals_6 = _name_6.equals("short");
          if (_equals_6) {
            boolean _xifexpression_15 = false;
            EClassifier _class__7 = right.getClass_();
            String _name_7 = _class__7.getName();
            boolean _equals_7 = _name_7.equals("int");
            if (_equals_7) {
              boolean _xifexpression_16 = false;
              if ((literal instanceof IntLiteral)) {
                boolean _xifexpression_17 = false;
                boolean _and_2 = false;
                int _value_4 = ((IntLiteral) literal).getValue();
                boolean _greaterEqualsThan_2 = (_value_4 >= Short.MIN_VALUE);
                if (!_greaterEqualsThan_2) {
                  _and_2 = false;
                } else {
                  int _value_5 = ((IntLiteral) literal).getValue();
                  boolean _lessEqualsThan_2 = (_value_5 <= Short.MAX_VALUE);
                  _and_2 = _lessEqualsThan_2;
                }
                if (_and_2) {
                  _xifexpression_17 = true;
                } else {
                  _xifexpression_17 = false;
                }
                _xifexpression_16 = _xifexpression_17;
              } else {
                boolean _xifexpression_18 = false;
                if ((literal instanceof ArrayLiteral)) {
                  _xifexpression_18 = this.checkAllLiteralsArtOfType(IntLiteral.class, ((ArrayLiteral) literal));
                }
                _xifexpression_16 = _xifexpression_18;
              }
              _xifexpression_15 = _xifexpression_16;
            } else {
              _xifexpression_15 = false;
            }
            _xifexpression_14 = _xifexpression_15;
          } else {
            _xifexpression_14 = false;
          }
          _xifexpression_9 = _xifexpression_14;
        }
        _xifexpression_4 = _xifexpression_9;
      }
      _xifexpression = _xifexpression_4;
    }
    return _xifexpression;
  }
  
  /**
   * Check in depth if all elements match the specific type.
   */
  public boolean checkAllLiteralsArtOfType(final Class<? extends Literal> type, final ArrayLiteral literal) {
    EList<Literal> _literals = literal.getLiterals();
    final Function1<Literal, Boolean> _function = new Function1<Literal, Boolean>() {
      public Boolean apply(final Literal element) {
        boolean _xifexpression = false;
        if ((element instanceof ArrayLiteral)) {
          _xifexpression = RecordLangValidator.this.checkAllLiteralsArtOfType(type, ((ArrayLiteral) element));
        } else {
          _xifexpression = type.isInstance(element);
        }
        return Boolean.valueOf(_xifexpression);
      }
    };
    return IterableExtensions.<Literal>forall(_literals, _function);
  }
  
  /**
   * Compute the classifier for a literal.
   */
  protected Classifier _getType(final StringLiteral literal) {
    Classifier _xifexpression = null;
    String _value = literal.getValue();
    int _length = _value.length();
    boolean _notEquals = (_length != 1);
    if (_notEquals) {
      EDataType _eType = PrimitiveTypes.ESTRING.getEType();
      _xifexpression = this.createPrimitiveClassifier(_eType);
    } else {
      EDataType _eType_1 = PrimitiveTypes.ECHAR.getEType();
      _xifexpression = this.createPrimitiveClassifier(_eType_1);
    }
    return _xifexpression;
  }
  
  protected Classifier _getType(final IntLiteral literal) {
    EDataType _eType = PrimitiveTypes.EINT.getEType();
    return this.createPrimitiveClassifier(_eType);
  }
  
  protected Classifier _getType(final FloatLiteral literal) {
    EDataType _eType = PrimitiveTypes.EFLOAT.getEType();
    return this.createPrimitiveClassifier(_eType);
  }
  
  protected Classifier _getType(final BooleanLiteral literal) {
    EDataType _eType = PrimitiveTypes.EBOOLEAN.getEType();
    return this.createPrimitiveClassifier(_eType);
  }
  
  protected Classifier _getType(final ConstantLiteral literal) {
    Constant _value = literal.getValue();
    return _value.getType();
  }
  
  protected Classifier _getType(final BuiltInValueLiteral literal) {
    Classifier _switchResult = null;
    String _value = literal.getValue();
    boolean _matched = false;
    if (!_matched) {
      if (Objects.equal(_value, "KIEKER_VERSION")) {
        _matched=true;
        EDataType _eType = PrimitiveTypes.ESTRING.getEType();
        _switchResult = this.createPrimitiveClassifier(_eType);
      }
    }
    return _switchResult;
  }
  
  protected Classifier _getType(final ArrayLiteral literal) {
    EList<Literal> _literals = literal.getLiterals();
    Literal _get = _literals.get(0);
    final Classifier classifier = this.getType(_get);
    final ArraySize size = RecordLangFactory.eINSTANCE.createArraySize();
    EList<Literal> _literals_1 = literal.getLiterals();
    int _size = _literals_1.size();
    size.setSize(_size);
    EList<ArraySize> _sizes = classifier.getSizes();
    _sizes.add(0, size);
    return classifier;
  }
  
  protected Classifier _getType(final Literal literal) {
    try {
      throw new InternalErrorException("Unhandled literal type");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  public Classifier createPrimitiveClassifier(final EDataType type) {
    final Classifier classifier = RecordLangFactory.eINSTANCE.createClassifier();
    classifier.setClass(type);
    return classifier;
  }
  
  /**
   * Compare types of a property for equality including package name.
   */
  public boolean typeAndPackageIdentical(final Classifier left, final Classifier right) {
    de.cau.cs.se.instrumentation.rl.recordLang.Package _package = left.getPackage();
    boolean _notEquals = (!Objects.equal(_package, null));
    if (_notEquals) {
      de.cau.cs.se.instrumentation.rl.recordLang.Package _package_1 = right.getPackage();
      boolean _notEquals_1 = (!Objects.equal(_package_1, null));
      if (_notEquals_1) {
        de.cau.cs.se.instrumentation.rl.recordLang.Package _package_2 = left.getPackage();
        de.cau.cs.se.instrumentation.rl.recordLang.Package _package_3 = right.getPackage();
        boolean _equals = _package_2.equals(_package_3);
        if (_equals) {
          return this.typeIdentical(left, right);
        } else {
          return false;
        }
      } else {
        return false;
      }
    } else {
      return this.typeIdentical(left, right);
    }
  }
  
  /**
   * Compare types of a property for equality.
   */
  public boolean typeIdentical(final Classifier left, final Classifier right) {
    Class<? extends Classifier> _class = left.getClass();
    Class<? extends Classifier> _class_1 = right.getClass();
    boolean _equals = _class.equals(_class_1);
    if (_equals) {
      EList<ArraySize> _sizes = left.getSizes();
      int _size = _sizes.size();
      EList<ArraySize> _sizes_1 = right.getSizes();
      int _size_1 = _sizes_1.size();
      boolean _equals_1 = (_size == _size_1);
      if (_equals_1) {
        int i = 0;
        while ((i < left.getSizes().size())) {
          EList<ArraySize> _sizes_2 = left.getSizes();
          ArraySize _get = _sizes_2.get(i);
          int _size_2 = _get.getSize();
          EList<ArraySize> _sizes_3 = right.getSizes();
          ArraySize _get_1 = _sizes_3.get(i);
          int _size_3 = _get_1.getSize();
          boolean _notEquals = (_size_2 != _size_3);
          if (_notEquals) {
            return false;
          }
        }
        return true;
      } else {
        return false;
      }
    } else {
      return false;
    }
  }
  
  public Pair<Property, Property> findDuplicate(final Property property, final Collection<Property> properties) {
    final Function1<Property, Boolean> _function = new Function1<Property, Boolean>() {
      public Boolean apply(final Property p) {
        boolean _and = false;
        String _name = property.getName();
        String _name_1 = p.getName();
        boolean _equals = _name.equals(_name_1);
        if (!_equals) {
          _and = false;
        } else {
          boolean _notEquals = (!Objects.equal(p, property));
          _and = _notEquals;
        }
        return Boolean.valueOf(_and);
      }
    };
    final Property second = IterableExtensions.<Property>findFirst(properties, _function);
    return new Pair<Property, Property>(property, second);
  }
  
  public Classifier getType(final Literal literal) {
    if (literal instanceof ArrayLiteral) {
      return _getType((ArrayLiteral)literal);
    } else if (literal instanceof BooleanLiteral) {
      return _getType((BooleanLiteral)literal);
    } else if (literal instanceof BuiltInValueLiteral) {
      return _getType((BuiltInValueLiteral)literal);
    } else if (literal instanceof ConstantLiteral) {
      return _getType((ConstantLiteral)literal);
    } else if (literal instanceof FloatLiteral) {
      return _getType((FloatLiteral)literal);
    } else if (literal instanceof IntLiteral) {
      return _getType((IntLiteral)literal);
    } else if (literal instanceof StringLiteral) {
      return _getType((StringLiteral)literal);
    } else if (literal != null) {
      return _getType(literal);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(literal).toString());
    }
  }
}
